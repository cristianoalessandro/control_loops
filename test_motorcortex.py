import nest
import numpy as np
import matplotlib.pyplot as plt
import trajectories as tj
import time

from motorcortex import MotorCortex
from population_view import plotPopulation
from util import savePattern
from population_view import PopView
from pointMass import PointMass

nest.Install("util_neurons_module")
res = nest.GetKernelStatus("resolution")

# Randomize
msd = int( time.time() * 1000.0 )
N_vp = nest.GetKernelStatus(['total_num_virtual_procs'])[0]
nest.SetKernelStatus({'rng_seeds' : range(msd+N_vp+1, msd+2*N_vp+1)})

m      = 5.0
ptMass = PointMass(mass=m)
njt    = ptMass.numVariables()

# Neuron neurons
N = 20

time_span = 1000.0
time_vect = np.linspace(0, time_span, num=int(np.round(time_span/res)), endpoint=True)

pthDat = "./data/"

init_pos = np.array([0.0,0.0])
tgt_pos  = np.array([10.0,10.0])
trj, pol = tj.minimumJerk(init_pos, tgt_pos, time_vect)

tgt_real = np.array([15.0,0.0])
trj_real, pol = tj.minimumJerk(init_pos, tgt_real, time_vect)
trj_real = trj

# Error in joint trajectory
trj_err = trj-trj_real
#trj_err = np.zeros(shape=(time_vect.size,njt))
#trj_err[:,0] = -15.0
savePattern(trj_err, pthDat+"error")


####### Error population (goes into motor cortex feedback)
err_param = {
    "base_rate": 0.0, # Feedforward neurons
    "kp": 1.0
    }

err_pop_p = []
err_pop_n = []
for i in range(njt):
    # Positive population (joint i)
    tmp_pop_p = nest.Create("tracking_neuron", n=N, params=err_param)
    nest.SetStatus(tmp_pop_p, {"pos": True, "pattern_file": pthDat+"error"+"_"+str(i)+".dat"})
    err_pop_p.append( PopView(tmp_pop_p,time_vect) )

    # Negative population (joint i)
    tmp_pop_n = nest.Create("tracking_neuron", n=N, params=err_param)
    nest.SetStatus(tmp_pop_n, {"pos": False, "pattern_file": pthDat+"error"+"_"+str(i)+".dat"})
    err_pop_n.append( PopView(tmp_pop_n,time_vect) )


####### Motor cortex
mc_param = {
    "ffwd_base_rate": 0.0, # Feedforward neurons
    "ffwd_kp": 10.0,
    "fbk_base_rate": 0.0,  # Feedback neurons
    "fbk_kp": 10.0,
    "out_base_rate": 0.0,  # Summation neurons
    "out_kp":1.0,
    "wgt_ffwd_out": 1.0,   # Connection weight from ffwd to output neurons (must be positive)
    "wgt_fbk_out": 1.0     # Connection weight from fbk to output neurons (must be positive)
    }

mc = MotorCortex(N, time_vect, trj, ptMass, pthDat, **mc_param)


# ####### Connections (error to motor cortex feedback)
for i in range(njt):
    err_pop_p[i].connect(mc.fbk_p[i], rule='one_to_one', w= 1.0)
    err_pop_n[i].connect(mc.fbk_n[i], rule='one_to_one', w=-1.0)


############### TEST ANALOG SIGNALS

# Visualize initial planned trajectory
fig, ax = plt.subplots(2,1,sharex=True)
ax[0].plot( time_vect,mc.getJointTrajectory(),label='des' )
ax[0].grid()
ax[0].plot( time_vect,trj_real,linestyle=':',label='real' )
ax[0].grid()
ax[0].legend()
ax[1].plot( time_vect,mc.getMotorCommands() )
ax[1].grid()
plt.suptitle("Simulation 1")

# Change planned trajectory
# Joint trajectory (this will be generated by planner)
#init_pos = np.array([0.0,0.0])
#tgt_pos  = np.array([-8.0,4.0])
#trj_new, pol = tj.minimumJerk(init_pos, tgt_pos, time_vect)
#mc.generateMotorCommands(trj_new)

#fig, ax = plt.subplots(2,1,sharex=True)
#ax[0].plot( time_vect,mc.getMotorCommands() )
#ax[0].grid()
#ax[1].plot( time_vect,mc.getJointTrajectory() )
#ax[1].grid()
#plt.suptitle("Simulation 2")
#plt.show()

#plt.figure()
#plt.plot(time_vect,error)

###################### SIMULATE
# Simulate
nest.Simulate(time_span)


###################### PLOTTING
# Populations
for i in range(njt):
    plotPopulation(time_vect, err_pop_p[i], err_pop_n[i], "Error, joint "+str(i+1) )
    plotPopulation(time_vect, mc.ffwd_p[i], mc.ffwd_n[i], "Motor cortex feedforward, joint "+str(i+1) )
    plotPopulation(time_vect, mc.fbk_p[i], mc.fbk_n[i], "Motor cortex feedback, joint "+str(i+1) )
    plotPopulation(time_vect, mc.out_p[i], mc.out_n[i], "Motor cortex output, joint "+str(i+1) )

# Feedforward and output populations (same scale)
fig, ax = plt.subplots(2,1)
for i in range(njt):
    mc.ffwd_p[i].plot_rate(time_vect,ax=ax[i],bar=False,color='r',label='ffwd')
    mc.ffwd_n[i].plot_rate(time_vect,ax=ax[i],bar=False,title='Joint '+str(i+1),color='b')
    mc.out_p[i].plot_rate(time_vect,ax=ax[i],bar=False,color='r',linestyle=':',label='out')
    mc.out_n[i].plot_rate(time_vect,ax=ax[i],bar=False,title='Joint '+str(i+1),color='b',linestyle=':')

ax[0].set_title('spike rate')
plt.legend()
plt.show()
